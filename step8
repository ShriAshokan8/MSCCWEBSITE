Step 8 – Add Firestore Security Rules for MSC Nexus (auth, roles, permissions)

Context:
- Firebase Auth, roles, sharedUid, and dual-email logic are implemented in the wrapper.
- Firestore now stores:
  - users (keyed by sharedUid, containing role, sharedUid, etc.)
  - workspaces
  - folders
  - documents (with owner, sharedWith, content, etc.)
- The MSC Nexus Editor uses Firestore for loading, saving, and sharing.
- So far, all permission checks have been done in frontend logic only.
- Now I want proper Firestore security rules to enforce the same rules on the backend.

Important:
- Do NOT change the Firebase project ID or config.
- Do NOT change collection names unless absolutely necessary.
- Do NOT remove frontend checks; just add backend enforcement.

Your tasks for Step 8:

------------------------------------------------------------
1. Create a Firestore rules file in the repo
------------------------------------------------------------

Create (or update) a file at:

firestore.rules

This is where all Firestore security rules for MSC Nexus will live.

------------------------------------------------------------
2. Basic authentication + domain checks
------------------------------------------------------------

At the top of the rules, require that:

- request.auth != null
- request.auth.token.email exists
- email ends with:
  - "@hfed.net"
  - OR "@harrispurley.org.uk"

If any of these fail → deny all access.

This ensures:
- Only logged-in school accounts can touch Firestore.

------------------------------------------------------------
3. Access to users collection
------------------------------------------------------------

We previously designed users/{sharedUid} with fields:
- email
- primaryEmail
- linkedEmails
- role
- mustChangePassword
- sharedUid

Because users are keyed by sharedUid (not auth.uid), we will:

- Allow clients to READ their own user document by matching email.
- Completely block client-side writes to users.
- Assume that create/update of user docs is handled via Admin scripts or backend tools.

Rules for collection "users":

- allow read:
  - request.auth != null
  - AND resource.data.linkedEmails (or email/primaryEmail) contains request.auth.token.email

- deny write:
  - no client can write to users (create/update/delete)

This ensures that:
- Users can read their own role and sharedUid.
- They cannot escalate privileges or change roles themselves.

------------------------------------------------------------
4. Access to workspaces
------------------------------------------------------------

Collection: workspaces

Each doc:
- name
- createdBy (sharedUid)
- createdAt

Rules:
- allow read:
  - if authenticated and domain valid (already enforced globally)
- allow create:
  - if authenticated and domain valid
- allow update/delete:
  - only if:
    - resource.data.createdBy == userSharedUid (from their users doc)
    - OR userRole is Director, DeputyDirector, or StaffCoordinator

You must implement helper functions in rules like:

- getUserDoc()
- userSharedUid()
- userRole()
- isLeadershipRole()

(See section 7 below.)

------------------------------------------------------------
5. Access to folders
------------------------------------------------------------

Collection: folders

Each doc:
- name
- workspaceId
- owner (sharedUid)
- sharedWith (array of sharedUid)
- createdAt

Rules:

allow read:
- if authenticated and domain valid.

allow create:
- if authenticated and domain valid
- any user can create a folder

allow update/delete:
- if:
  - user is folder.owner
  OR user.sharedUid in folder.sharedWith
  OR userRole is Director, DeputyDirector, or StaffCoordinator

This must mirror the frontend permission logic.

------------------------------------------------------------
6. Access to documents
------------------------------------------------------------

Collection: documents

Each doc:
- title
- folderId
- workspaceId
- content
- owner (sharedUid)
- sharedWith (array of sharedUid)
- createdAt
- updatedAt

Rules:

allow read:
- if authenticated and domain valid

allow create:
- if authenticated and domain valid
- any user can create a document (subject to folder ownership rules if you want to enforce that)

allow update:
- only if:
  - user is document.owner
  OR user.sharedUid in document.sharedWith
  OR user.sharedUid in corresponding folder.sharedWith
  OR userRole is Director, DeputyDirector, or StaffCoordinator

allow delete:
- only if:
  - user is document.owner
  OR userRole is Director, DeputyDirector, or StaffCoordinator

You may need to read folder data inside document rules (using get() on folders collection) to check folder.sharedWith.

------------------------------------------------------------
7. Helper functions in Firestore rules
------------------------------------------------------------

Inside firestore.rules, define helper functions for:

- function isSignedIn() {
    return request.auth != null
      && request.auth.token.email != null;
  }

- function isAllowedDomain() {
    return request.auth.token.email.matches(".*@hfed\\.net$")
        || request.auth.token.email.matches(".*@harrispurley\\.org\\.uk$");
  }

- function getUserByEmail() {
    // get the matching user doc by email or linkedEmails
    // e.g. use a dedicated mapping collection if needed:
    // usersAuth/{authUid} -> { sharedUid, role }
    // For now, you can assume we have or will add a usersAuth collection keyed by auth.uid
  }

Because Firestore rules cannot query arbitrarily, you may:

- Introduce a "usersAuth" collection keyed by auth.uid that stores:
  - sharedUid
  - role

Then:

- function userSharedUid() {
    return get(/databases/$(database)/documents/usersAuth/$(request.auth.uid)).data.sharedUid;
  }

- function userRole() {
    return get(/databases/$(database)/documents/usersAuth/$(request.auth.uid)).data.role;
  }

- function isLeadership() {
    return userRole() in ["Director", "DeputyDirector", "StaffCoordinator"];
  }

Use these helper functions in rules for workspaces, folders, documents.

In this step, just implement the rules assuming "usersAuth" exists; we can populate it later via Admin code.

------------------------------------------------------------
8. Disallow any other collections by default
------------------------------------------------------------

At the bottom of rules:
- Deny all access to collections that are not explicitly covered.

This prevents accidental open collections.

------------------------------------------------------------
9. Add comments + summary
------------------------------------------------------------

Add comments in firestore.rules that explain:

- Which collections are used by MSC Nexus
- How roles are resolved
- How sharedUid is linked to auth.uid
- Which paths are read-only to clients (e.g. users collection)

------------------------------------------------------------
10. Commit for Step 8
------------------------------------------------------------

Commit:

- firestore.rules (new or updated)

Update PR description with:
- An overview of the Firestore security model
- How auth + roles + sharedUid are used inside rules
- Any assumptions (like existence of usersAuth collection keyed by auth.uid)

End of Step 8.
